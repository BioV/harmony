---
title: "Quick start to Harmony"
author: "Korsunsky et al.: Fast, sensitive, and accurate integration of single 
cell data with Harmony"
output:
  BiocStyle::html_document:
    code_folding: show
    number_sections: yes
    toc: yes  
    fig_width: 7
    fig_height: 2.5
vignette: >
    %\VignetteIndexEntry{Quick start to Harmony}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8} 
---
  
  
```{r, message=FALSE, warning=FALSE, echo=FALSE}
library(dplyr)
library(ggplot2)
library(harmony)
library(cowplot)

```

```{r, echo=FALSE}

colors_use <- c(`jurkat` = '#810F7C', `t293` = '#D09E2D',`half` = '#006D2C')


do_scatter <- function(umap_use, meta_data, label_name, no_guides = TRUE,
                       do_labels = TRUE, nice_names, 
                       palette_use = colors_use,
                       pt_size = 4, point_size = .5, base_size = 12, 
                       do_points = TRUE, do_density = FALSE, h = 6, w = 8) {
    umap_use <- umap_use[, 1:2]
    colnames(umap_use) <- c('X1', 'X2')
    plt_df <- umap_use %>% data.frame() %>% 
        cbind(meta_data) %>% 
        dplyr::sample_frac(1L) 
    plt_df$given_name <- plt_df[[label_name]]
    
    if (!missing(nice_names)) {
        plt_df %<>%
            dplyr::inner_join(nice_names, by = "given_name") %>% 
            subset(nice_name != "" & !is.na(nice_name))
        
        plt_df[[label_name]] <- plt_df$nice_name        
    }
    
    plt <- plt_df %>% 
        ggplot(aes_string("X1", "X2", col = label_name, fill = label_name)) + 
        theme_test(base_size = base_size) + 
        theme(panel.background = element_rect(fill = NA, color = "black")) + 
        guides(color = guide_legend(override.aes = list(stroke = 1, alpha = 1,
                                                        shape = 16, size = 4)), 
               alpha = FALSE) +
        scale_color_manual(values = palette_use) + 
        scale_fill_manual(values = palette_use) +    
        theme(plot.title = element_text(hjust = .5)) + 
        labs(x = "PC 1", y = "PC 2") 
    
    if (do_points) 
        plt <- plt + geom_point(shape = '.')
    if (do_density) 
        plt <- plt + geom_density_2d()    
    
    
    if (no_guides)
        plt <- plt + guides(col = FALSE, fill = FALSE, alpha = FALSE)
    
    if (do_labels) {
        data_labels <- plt_df %>% 
            dplyr::group_by_(label_name) %>% 
            dplyr::summarise(X1 = mean(X1), X2 = mean(X2)) %>% 
            dplyr::ungroup()
        
        plt <- plt + geom_label(data = data_labels, label.size = NA,
                        aes_string(label = label_name), 
                        color = "white", size = pt_size, alpha = 1,
                        segment.size = 0) +
                guides(col = FALSE, fill = FALSE)
    }
    
    return(plt)
}

```

# Introduction

Harmony is an algorithm for performing integration of single cell genomics
datasets. Please check out our latest 
[preprint on bioRxiv](https://www.biorxiv.org/content/10.1101/461954v2). 

![](main.jpg)

# Installation

Install Harmony with standard Bioconductor commands. 

```{r eval=FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("harmony", version = "3.8")

```

# Integrating cell line datasets from 10X

The example below follows Figure 2 in the manuscript. 

We downloaded 3 cell line datasets from the 10X website. The first two (jurkat
and 293t) come from pure cell lines while the *half* dataset is a 50:50
mixture of Jurkat and HEK293T cells. We inferred cell type with the canonical 
marker XIST, since the two cell lines come from 1 male and 1 female donor. 

* support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/jurkat
* support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/293t
* support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/jurkat:293t_50:50

We library normalized the cells, log transformed the counts, and scaled the 
genes. Then we performed PCA and kept the top 20 PCs. The PCA embeddings and 
meta data are available as part of this package. 


```{r}
data(cell_lines)
V <- cell_lines$scaled_pcs
meta_data <- cell_lines$meta_data

```

Initially, the cells cluster by both dataset (left) and cell type (right). 

```{r}
p1 <- do_scatter(V, meta_data, 'dataset') + 
    labs(title = 'Colored by dataset')
p2 <- do_scatter(V, meta_data, 'cell_type') + 
    labs(title = 'Colored by cell type')

cowplot::plot_grid(p1, p2)

```

Let's run Harmony to remove the influence of dataset-of-origin from the
embedding. By default, Harmony accepts a normalized gene expression matrix and
performs PCA. Since here we already have the PCs, we specify *do_pca=FALSE*.
The matrix *harmony_embeddings* is the matrix of Harmony corrected PCA
embeddings. 

```{r}
harmony_embeddings <- harmony::HarmonyMatrix(
    V, meta_data, 'dataset', do_pca = FALSE, verbose=FALSE
)

```

After Harmony, the datasets are now mixed (left) and the cell types are still
separate (right). 

```{r}
p1 <- do_scatter(harmony_embeddings, meta_data, 'dataset') + 
    labs(title = 'Colored by dataset')
p2 <- do_scatter(harmony_embeddings, meta_data, 'cell_type') + 
    labs(title = 'Colored by cell type')
cowplot::plot_grid(p1, p2, nrow = 1)

```

# Next Steps

## Interfacing to software packages

You can also run Harmony as part of an established pipeline in several
packages, such as Seurat, MUDAN, and scran. For these vignettes, please
[visit our website](software.broadinstitute.org/harmony). 

The most common way to run Harmony is on reduced dimensions such as PC
embeddings from principal component analysis (PCA). If you use low
dimensional embeddings, set `do_pca = FALSE`. A small single-cell
RNA-seq dataset is include in the Harmony package.

```r
library(harmony)

data(cell_lines)

cell_lines$meta_data[1:5,]
## # A tibble: 6 x 5
##   cell_id               dataset nGene percent_mito cell_type
##   <chr>                 <chr>   <int>        <dbl> <chr>
## 1 half_GTACGAACCACCAA   half     1508       0.0148 jurkat
## 2 t293_AGGTCATGCACTTT   t293     4009       0.0232 t293
## 3 half_ATAGTTGACTTCTA   half     3545       0.0153 jurkat
## 4 half_GAGCGGCTTGCTTT   half     2450       0.0170 jurkat
## 5 jurkat_CTGATACTCCGTAA jurkat   2388       0.0601 jurkat

cell_lines$scaled_pcs[1:5,1:5]
##              X1            X2            X3           X4           X5
## 1:  0.002806741 -0.0014502980 -0.0063901369 0.0002824677  0.001444069
## 2: -0.011669691  0.0008773044  0.0008972694 0.0013239566 -0.003291763
## 3:  0.009334467 -0.0069718865 -0.0025989384 0.0018824674 -0.003803677
## 4:  0.006339979 -0.0025175931 -0.0043900882 0.0002737979 -0.002497476
## 5:  0.008545583  0.0070866873 -0.0022541011 0.0016793801  0.004554607

# Run the Harmony algorithm on the PCs.
harmonized_pcs <- HarmonyMatrix(
  data_mat  = cell_lines$scaled_pcs,
  meta_data = cell_lines$meta_data,
  vars_use  = "dataset",
  do_pca    = FALSE
)

harmonized_pcs[1:5,1:5]
##                X1            X2            X3           X4           X5
## [1,]  0.004328379  0.0023091631 -4.207100e-03 0.0005384881  0.001530069
## [2,] -0.011658395  0.0001938143  3.168350e-04 0.0010923436 -0.003427295
## [3,]  0.010934694 -0.0025131628 -6.655157e-05 0.0019817633 -0.003617146
## [4,]  0.008157150  0.0018712240 -1.502931e-03 0.0006383834 -0.002240632
## [5,]  0.006956255  0.0032281410 -4.582874e-03 0.0013581108  0.004490102
```

## Normalized gene matrix

You can also run Harmony on a sparse matrix of library size normalized
expression counts. The `HarmonyMatrix()` function will scale expression data,
run PCA, and run the Harmony integration algorithm.

```r
library(harmony)
my_harmony_embeddings <- HarmonyMatrix(
  data_mat  = normalized_counts,
  meta_data = meta_data,
  vars_use  = "dataset"
)
```

## Seurat 

You can run Harmony within your Seurat workflow. You'll only need to make two
changes to your code.

1. Run Harmony with the `RunHarmony()` function.
2. In downstream analyses, use the Harmony embeddings instead of PCA. 

For example, run Harmony and then UMAP in two lines.  

```r
seuratObj <- RunHarmony(seuratObj, "dataset")
seuratObj <- RunUMAP(seuratObj, reduction = "harmony")
```

For details, check out these vignettes: 

- [Seurat V2](http://htmlpreview.github.io/?https://github.com/immunogenomics/harmony/blob/master/docs/SeuratV2.html)
- [Seurat V3](http://htmlpreview.github.io/?https://github.com/immunogenomics/harmony/blob/master/docs/SeuratV3.html)

## MUDAN

You can run Harmony with functions from the [MUDAN][mudan] R package. For more,
details, check out this [vignette][mudan-vignette].

[mudan]: https://github.com/jefworks/mudan
[mudan-vignette]: http://htmlpreview.github.io/?https://github.com/immunogenomics/harmony/blob/master/docs/mudan.html

## Harmony with two or more covariates

Harmony can integrate over multiple covariates. To do this, specify a vector
covariates to integrate. 

```r
harmonized_pcs <- HarmonyMatrix(
  data_mat  = scaled_pcs,
  meta_data = meta_data,
  vars_use  = c("dataset", "donor", "batch_id"), # multiple covariates
  do_pca    = FALSE
)
```

Do the same with your Seurat object: 

```r
seuratObject <- RunHarmony(seuratObject, c("dataset", "donor", "batch_id"))
```


## Detailed breakdown of the Harmony algorithm

For more details on how each part of Harmony works, consult our more detailed 
[vignette](software.broadinstitute.org/harmony/vignettes/walkthrough.html)
"Detailed Walkthrough of Harmony Algorithm".

# Session Info

```{r}
sessionInfo()

```









